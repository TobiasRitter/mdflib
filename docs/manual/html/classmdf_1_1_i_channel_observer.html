<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MDF Lib: mdf::IChannelObserver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="utillib.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MDF Lib<span id="projectnumber">&#160;2.2</span>
   </div>
   <div id="projectbrief">Interface against MDF 3/4 files</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemdf.html">mdf</a></li><li class="navelem"><a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmdf_1_1_i_channel_observer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mdf::IChannelObserver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The channel observer object shall hold all samples for a channel.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ichannelobserver_8h_source.html">ichannelobserver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdf::IChannelObserver:</div>
<div class="dyncontent">
<div class="center"><img src="classmdf_1_1_i_channel_observer__inherit__graph.png" border="0" usemap="#amdf_1_1_i_channel_observer_inherit__map" alt="Inheritance graph"/></div>
<map name="amdf_1_1_i_channel_observer_inherit__map" id="amdf_1_1_i_channel_observer_inherit__map">
<area shape="rect" title="The channel observer object shall hold all samples for a channel." alt="" coords="5,79,157,104"/>
<area shape="rect" href="classmdf_1_1_i_sample_observer.html" title="Interface to a sample observer that handle incoming samples events." alt="" coords="7,5,156,31"/>
<area shape="poly" title=" " alt="" coords="84,44,84,79,79,79,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdf::IChannelObserver:</div>
<div class="dyncontent">
<div class="center"><img src="classmdf_1_1_i_channel_observer__coll__graph.png" border="0" usemap="#amdf_1_1_i_channel_observer_coll__map" alt="Collaboration graph"/></div>
<map name="amdf_1_1_i_channel_observer_coll__map" id="amdf_1_1_i_channel_observer_coll__map">
<area shape="rect" title="The channel observer object shall hold all samples for a channel." alt="" coords="67,253,219,279"/>
<area shape="rect" href="classmdf_1_1_i_sample_observer.html" title="Interface to a sample observer that handle incoming samples events." alt="" coords="5,179,155,204"/>
<area shape="poly" title=" " alt="" coords="101,213,135,251,130,255,97,217"/>
<area shape="rect" href="classmdf_1_1_i_data_group.html" title="Interface to a data group (DG) block." alt="" coords="35,80,151,105"/>
<area shape="poly" title=" " alt="" coords="78,118,72,130,71,155,77,178,72,179,66,156,67,129,73,115"/>
<area shape="rect" href="classmdf_1_1_i_block.html" title="Base class for all MDF blocks." alt="" coords="107,5,194,31"/>
<area shape="poly" title=" " alt="" coords="135,43,105,81,101,78,131,40"/>
<area shape="rect" href="classmdf_1_1_i_channel.html" title="Defines a MDF channel (CN) block." alt="" coords="157,129,259,155"/>
<area shape="poly" title=" " alt="" coords="164,42,205,128,200,130,159,44"/>
<area shape="poly" title=" " alt="" coords="198,168,151,255,146,252,193,166"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78036a2445f08c48a0f50abb252611d2" id="r_a78036a2445f08c48a0f50abb252611d2"><td class="memItemLeft" align="right" valign="top"><a id="a78036a2445f08c48a0f50abb252611d2" name="a78036a2445f08c48a0f50abb252611d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IChannelObserver</b> (const <a class="el" href="classmdf_1_1_i_data_group.html">IDataGroup</a> &amp;dataGroup, const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp;channel)</td></tr>
<tr class="memdesc:a78036a2445f08c48a0f50abb252611d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a78036a2445f08c48a0f50abb252611d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57212c17801d0efeebb0e15666db9d21" id="r_a57212c17801d0efeebb0e15666db9d21"><td class="memItemLeft" align="right" valign="top"><a id="a57212c17801d0efeebb0e15666db9d21" name="a57212c17801d0efeebb0e15666db9d21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~IChannelObserver</b> () override=default</td></tr>
<tr class="memdesc:a57212c17801d0efeebb0e15666db9d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a57212c17801d0efeebb0e15666db9d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139cc78997776091595b1f54f29418d5" id="r_a139cc78997776091595b1f54f29418d5"><td class="memItemLeft" align="right" valign="top"><a id="a139cc78997776091595b1f54f29418d5" name="a139cc78997776091595b1f54f29418d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IChannelObserver</b> (const <a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;)=delete</td></tr>
<tr class="separator:a139cc78997776091595b1f54f29418d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637511aa276d48783a055a5498df1e9" id="r_a3637511aa276d48783a055a5498df1e9"><td class="memItemLeft" align="right" valign="top"><a id="a3637511aa276d48783a055a5498df1e9" name="a3637511aa276d48783a055a5498df1e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IChannelObserver</b> (<a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3637511aa276d48783a055a5498df1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3fd0f581ab3179a2ecd043b87743c" id="r_a7ca3fd0f581ab3179a2ecd043b87743c"><td class="memItemLeft" align="right" valign="top"><a id="a7ca3fd0f581ab3179a2ecd043b87743c" name="a7ca3fd0f581ab3179a2ecd043b87743c"></a>
<a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;)=delete</td></tr>
<tr class="separator:a7ca3fd0f581ab3179a2ecd043b87743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f888d7ce88288de4bbb53814088cbb" id="r_ac6f888d7ce88288de4bbb53814088cbb"><td class="memItemLeft" align="right" valign="top"><a id="ac6f888d7ce88288de4bbb53814088cbb" name="ac6f888d7ce88288de4bbb53814088cbb"></a>
<a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmdf_1_1_i_channel_observer.html">IChannelObserver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac6f888d7ce88288de4bbb53814088cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6611bae034a767205da137b93bbf3aa" id="r_ad6611bae034a767205da137b93bbf3aa"><td class="memItemLeft" align="right" valign="top"><a id="ad6611bae034a767205da137b93bbf3aa" name="ad6611bae034a767205da137b93bbf3aa"></a>
virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>NofSamples</b> () const =0</td></tr>
<tr class="memdesc:ad6611bae034a767205da137b93bbf3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of samples. <br /></td></tr>
<tr class="separator:ad6611bae034a767205da137b93bbf3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d77b016c8225c9acc44e0b24711f37" id="r_a46d77b016c8225c9acc44e0b24711f37"><td class="memItemLeft" align="right" valign="top"><a id="a46d77b016c8225c9acc44e0b24711f37" name="a46d77b016c8225c9acc44e0b24711f37"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b> () const</td></tr>
<tr class="memdesc:a46d77b016c8225c9acc44e0b24711f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel name. <br /></td></tr>
<tr class="separator:a46d77b016c8225c9acc44e0b24711f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944b4093b9e83896b2687a87618b787e" id="r_a944b4093b9e83896b2687a87618b787e"><td class="memItemLeft" align="right" valign="top"><a id="a944b4093b9e83896b2687a87618b787e" name="a944b4093b9e83896b2687a87618b787e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Unit</b> () const</td></tr>
<tr class="memdesc:a944b4093b9e83896b2687a87618b787e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel unit. <br /></td></tr>
<tr class="separator:a944b4093b9e83896b2687a87618b787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164c91c7d6774c49a41d334c64668290" id="r_a164c91c7d6774c49a41d334c64668290"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164c91c7d6774c49a41d334c64668290">Channel</a> () const</td></tr>
<tr class="memdesc:a164c91c7d6774c49a41d334c64668290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the channel object.  <br /></td></tr>
<tr class="separator:a164c91c7d6774c49a41d334c64668290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5a1e2d4a99e8068231848f9ffaa8fe" id="r_a6d5a1e2d4a99e8068231848f9ffaa8fe"><td class="memItemLeft" align="right" valign="top"><a id="a6d5a1e2d4a99e8068231848f9ffaa8fe" name="a6d5a1e2d4a99e8068231848f9ffaa8fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMaster</b> () const</td></tr>
<tr class="memdesc:a6d5a1e2d4a99e8068231848f9ffaa8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this is the master channel. <br /></td></tr>
<tr class="separator:a6d5a1e2d4a99e8068231848f9ffaa8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bd6a3819c779ca9b326f1eefbfd685" id="r_a05bd6a3819c779ca9b326f1eefbfd685"><td class="memItemLeft" align="right" valign="top"><a id="a05bd6a3819c779ca9b326f1eefbfd685" name="a05bd6a3819c779ca9b326f1eefbfd685"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsArray</b> () const</td></tr>
<tr class="memdesc:a05bd6a3819c779ca9b326f1eefbfd685"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this channel is an array channel. <br /></td></tr>
<tr class="separator:a05bd6a3819c779ca9b326f1eefbfd685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd31f098621d481f001509ca8b3b4e76" id="r_abd31f098621d481f001509ca8b3b4e76"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd31f098621d481f001509ca8b3b4e76">Shape</a> () const</td></tr>
<tr class="memdesc:abd31f098621d481f001509ca8b3b4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shape vector that describes an array dimension.  <br /></td></tr>
<tr class="separator:abd31f098621d481f001509ca8b3b4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964af22898be38655cf46d965471ed4a" id="r_a964af22898be38655cf46d965471ed4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964af22898be38655cf46d965471ed4a">ReadVlsdData</a> (bool read_vlsd_data)</td></tr>
<tr class="memdesc:a964af22898be38655cf46d965471ed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property interface that defines if the VLSD raw data should be read or not.  <br /></td></tr>
<tr class="separator:a964af22898be38655cf46d965471ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ad7e4df590c1904e5788c47d93efa" id="r_a973ad7e4df590c1904e5788c47d93efa"><td class="memItemLeft" align="right" valign="top"><a id="a973ad7e4df590c1904e5788c47d93efa" name="a973ad7e4df590c1904e5788c47d93efa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadVlsdData</b> () const</td></tr>
<tr class="memdesc:a973ad7e4df590c1904e5788c47d93efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the read VLSD bytes property. <br /></td></tr>
<tr class="separator:a973ad7e4df590c1904e5788c47d93efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b6e85bdf1a75b68d1c84a49c56da60" id="r_ae5b6e85bdf1a75b68d1c84a49c56da60"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b6e85bdf1a75b68d1c84a49c56da60">ArraySize</a> () const</td></tr>
<tr class="memdesc:ae5b6e85bdf1a75b68d1c84a49c56da60"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is an array channel, this function returns the array size.  <br /></td></tr>
<tr class="separator:ae5b6e85bdf1a75b68d1c84a49c56da60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6ca9903ce2e7236b1bea4d978256d2" id="r_a4e6ca9903ce2e7236b1bea4d978256d2"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a4e6ca9903ce2e7236b1bea4d978256d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e6ca9903ce2e7236b1bea4d978256d2">GetChannelValue</a> (uint64_t sample, V &amp;value, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:a4e6ca9903ce2e7236b1bea4d978256d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the channel value for a sample.  <br /></td></tr>
<tr class="separator:a4e6ca9903ce2e7236b1bea4d978256d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e98dedf693b33943432a04dd88abc" id="r_adb2e98dedf693b33943432a04dd88abc"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:adb2e98dedf693b33943432a04dd88abc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb2e98dedf693b33943432a04dd88abc">GetChannelSamples</a> (std::vector&lt; V &gt; &amp;values) const</td></tr>
<tr class="memdesc:adb2e98dedf693b33943432a04dd88abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function that returns all non-scaled samples.  <br /></td></tr>
<tr class="separator:adb2e98dedf693b33943432a04dd88abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff05a7e1b6542d5d7e73397bc657ecc4" id="r_aff05a7e1b6542d5d7e73397bc657ecc4"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aff05a7e1b6542d5d7e73397bc657ecc4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff05a7e1b6542d5d7e73397bc657ecc4">GetChannelValues</a> (uint64_t sample, std::vector&lt; V &gt; &amp;values) const</td></tr>
<tr class="memdesc:aff05a7e1b6542d5d7e73397bc657ecc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of array channel values for a specific sample.  <br /></td></tr>
<tr class="separator:aff05a7e1b6542d5d7e73397bc657ecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18809112e05690a07e7e57ddb0d94807" id="r_a18809112e05690a07e7e57ddb0d94807"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a18809112e05690a07e7e57ddb0d94807"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18809112e05690a07e7e57ddb0d94807">GetEngValue</a> (uint64_t sample, V &amp;value, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:a18809112e05690a07e7e57ddb0d94807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering value for a specific value.  <br /></td></tr>
<tr class="separator:a18809112e05690a07e7e57ddb0d94807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae998c473b76df6076b930f897b65fd" id="r_aaae998c473b76df6076b930f897b65fd"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aaae998c473b76df6076b930f897b65fd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaae998c473b76df6076b930f897b65fd">GetEngSamples</a> (std::vector&lt; V &gt; &amp;values) const</td></tr>
<tr class="memdesc:aaae998c473b76df6076b930f897b65fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function that returns all scaled samples.  <br /></td></tr>
<tr class="separator:aaae998c473b76df6076b930f897b65fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c0e8598ff26095f14a1f4cbed1de1" id="r_adf6c0e8598ff26095f14a1f4cbed1de1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:adf6c0e8598ff26095f14a1f4cbed1de1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf6c0e8598ff26095f14a1f4cbed1de1">GetEngValues</a> (uint64_t sample, std::vector&lt; V &gt; &amp;values) const</td></tr>
<tr class="memdesc:adf6c0e8598ff26095f14a1f4cbed1de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of array values for a specific sample.  <br /></td></tr>
<tr class="separator:adf6c0e8598ff26095f14a1f4cbed1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819be1e44a252c08af1ae72b0815adba" id="r_a819be1e44a252c08af1ae72b0815adba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819be1e44a252c08af1ae72b0815adba">EngValueToString</a> (uint64_t sample) const</td></tr>
<tr class="memdesc:a819be1e44a252c08af1ae72b0815adba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that convert a sample value to a user friendly string.  <br /></td></tr>
<tr class="separator:a819be1e44a252c08af1ae72b0815adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af7d3ece557b14f80a5513193afd1e" id="r_ab4af7d3ece557b14f80a5513193afd1e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4af7d3ece557b14f80a5513193afd1e">GetOffsetList</a> () const</td></tr>
<tr class="memdesc:ab4af7d3ece557b14f80a5513193afd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample to VLSD offset list.  <br /></td></tr>
<tr class="separator:ab4af7d3ece557b14f80a5513193afd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02428742a22bf2b210365160e0cfb498" id="r_a02428742a22bf2b210365160e0cfb498"><td class="memItemLeft" align="right" valign="top"><a id="a02428742a22bf2b210365160e0cfb498" name="a02428742a22bf2b210365160e0cfb498"></a>
const std::vector&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidList</b> () const</td></tr>
<tr class="memdesc:a02428742a22bf2b210365160e0cfb498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample to valid list. <br  />
 <br /></td></tr>
<tr class="separator:a02428742a22bf2b210365160e0cfb498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7491961299d81291a23abcc07db5c" id="r_a92e7491961299d81291a23abcc07db5c"><td class="memItemLeft" align="right" valign="top"><a id="a92e7491961299d81291a23abcc07db5c" name="a92e7491961299d81291a23abcc07db5c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a92e7491961299d81291a23abcc07db5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetChannelValue</b> (uint64_t sample, std::string &amp;value, uint64_t array_index) const</td></tr>
<tr class="memdesc:a92e7491961299d81291a23abcc07db5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample channel value as a string. <br /></td></tr>
<tr class="separator:a92e7491961299d81291a23abcc07db5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fdaf8543e95bb761e8a2a9a8c5cac2" id="r_a60fdaf8543e95bb761e8a2a9a8c5cac2"><td class="memItemLeft" align="right" valign="top"><a id="a60fdaf8543e95bb761e8a2a9a8c5cac2" name="a60fdaf8543e95bb761e8a2a9a8c5cac2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a60fdaf8543e95bb761e8a2a9a8c5cac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetChannelValue</b> (uint64_t sample, std::vector&lt; uint8_t &gt; &amp;value, uint64_t array_index) const</td></tr>
<tr class="memdesc:a60fdaf8543e95bb761e8a2a9a8c5cac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample channel value as a byte array. <br /></td></tr>
<tr class="separator:a60fdaf8543e95bb761e8a2a9a8c5cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8567857451e8736029021f218921a3a2" id="r_a8567857451e8736029021f218921a3a2"><td class="memItemLeft" align="right" valign="top"><a id="a8567857451e8736029021f218921a3a2" name="a8567857451e8736029021f218921a3a2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8567857451e8736029021f218921a3a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetEngValue</b> (uint64_t sample, std::vector&lt; uint8_t &gt; &amp;value, uint64_t array_index) const</td></tr>
<tr class="memdesc:a8567857451e8736029021f218921a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample engineering (channel) value as a byte array. <br /></td></tr>
<tr class="separator:a8567857451e8736029021f218921a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmdf_1_1_i_sample_observer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classmdf_1_1_i_sample_observer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmdf_1_1_i_sample_observer.html">mdf::ISampleObserver</a></td></tr>
<tr class="memitem:ad4d01478f4c03c6c46fc814e13733b95 inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_ad4d01478f4c03c6c46fc814e13733b95"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ISampleObserver</b> (const <a class="el" href="classmdf_1_1_i_data_group.html">IDataGroup</a> &amp;data_group)</td></tr>
<tr class="memdesc:ad4d01478f4c03c6c46fc814e13733b95 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample observer constructor. <br /></td></tr>
<tr class="separator:ad4d01478f4c03c6c46fc814e13733b95 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b481cf73aea99311e77e9ef49e08b inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_a159b481cf73aea99311e77e9ef49e08b"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ISampleObserver</b> ()</td></tr>
<tr class="memdesc:a159b481cf73aea99311e77e9ef49e08b inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a159b481cf73aea99311e77e9ef49e08b inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3f2246ffc18810c5bd0f0ba638a34d inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_a1b3f2246ffc18810c5bd0f0ba638a34d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#a1b3f2246ffc18810c5bd0f0ba638a34d">AttachObserver</a> ()</td></tr>
<tr class="memdesc:a1b3f2246ffc18810c5bd0f0ba638a34d inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the observer to an observer list (publisher).  <br /></td></tr>
<tr class="separator:a1b3f2246ffc18810c5bd0f0ba638a34d inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1271fd85e2d576b51b4af717653eff inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_a9a1271fd85e2d576b51b4af717653eff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#a9a1271fd85e2d576b51b4af717653eff">DetachObserver</a> ()</td></tr>
<tr class="memdesc:a9a1271fd85e2d576b51b4af717653eff inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the observer from an observer list.  <br /></td></tr>
<tr class="separator:a9a1271fd85e2d576b51b4af717653eff inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1b137263f56d586e728b4d602925f1 inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_a8e1b137263f56d586e728b4d602925f1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#a8e1b137263f56d586e728b4d602925f1">OnSample</a> (uint64_t sample, uint64_t record_id, const std::vector&lt; uint8_t &gt; &amp;record)</td></tr>
<tr class="memdesc:a8e1b137263f56d586e728b4d602925f1 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer function that receives the sample record and parse out a channel value.  <br /></td></tr>
<tr class="separator:a8e1b137263f56d586e728b4d602925f1 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e0b9a800313fc8ed9fd4092ef45d8 inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_ae41e0b9a800313fc8ed9fd4092ef45d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#ae41e0b9a800313fc8ed9fd4092ef45d8">IsRecordIdNeeded</a> (uint64_t record_id) const</td></tr>
<tr class="memdesc:ae41e0b9a800313fc8ed9fd4092ef45d8 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that test if this observer needs to read a specific record.  <br /></td></tr>
<tr class="separator:ae41e0b9a800313fc8ed9fd4092ef45d8 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5370d41a04767162b5d8fcc1d0a3ed5d inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_a5370d41a04767162b5d8fcc1d0a3ed5d"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a5370d41a04767162b5d8fcc1d0a3ed5d inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#a5370d41a04767162b5d8fcc1d0a3ed5d">GetChannelValue</a> (const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp;channel, uint64_t sample, const std::vector&lt; uint8_t &gt; &amp;record, V &amp;value, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:a5370d41a04767162b5d8fcc1d0a3ed5d inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns a channel value.  <br /></td></tr>
<tr class="separator:a5370d41a04767162b5d8fcc1d0a3ed5d inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ffbdc7caae38e85dc54361d68c057 inherit pub_methods_classmdf_1_1_i_sample_observer" id="r_aec5ffbdc7caae38e85dc54361d68c057"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aec5ffbdc7caae38e85dc54361d68c057 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#aec5ffbdc7caae38e85dc54361d68c057">GetEngValue</a> (const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp;channel, uint64_t sample, const std::vector&lt; uint8_t &gt; &amp;record, V &amp;value, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:aec5ffbdc7caae38e85dc54361d68c057 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scaled sample value for the channel with the record bytes as input. This function is mainly for internal use but is used together with sample observers.  <br /></td></tr>
<tr class="separator:aec5ffbdc7caae38e85dc54361d68c057 inherit pub_methods_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a119853914104987a7f78a9d4995980e7" id="r_a119853914104987a7f78a9d4995980e7"><td class="memItemLeft" align="right" valign="top"><a id="a119853914104987a7f78a9d4995980e7" name="a119853914104987a7f78a9d4995980e7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampleUnsigned</b> (uint64_t sample, uint64_t &amp;value, uint64_t array_index) const =0</td></tr>
<tr class="memdesc:a119853914104987a7f78a9d4995980e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unsigned sample value. <br /></td></tr>
<tr class="separator:a119853914104987a7f78a9d4995980e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c482deccfe18ed5b240207103e0d71" id="r_a77c482deccfe18ed5b240207103e0d71"><td class="memItemLeft" align="right" valign="top"><a id="a77c482deccfe18ed5b240207103e0d71" name="a77c482deccfe18ed5b240207103e0d71"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampleSigned</b> (uint64_t sample, int64_t &amp;value, uint64_t array_index) const =0</td></tr>
<tr class="memdesc:a77c482deccfe18ed5b240207103e0d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signed sample value. <br /></td></tr>
<tr class="separator:a77c482deccfe18ed5b240207103e0d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c4508e5d2498979fe9060380d9ed44" id="r_a10c4508e5d2498979fe9060380d9ed44"><td class="memItemLeft" align="right" valign="top"><a id="a10c4508e5d2498979fe9060380d9ed44" name="a10c4508e5d2498979fe9060380d9ed44"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampleFloat</b> (uint64_t sample, double &amp;value, uint64_t array_index) const =0</td></tr>
<tr class="memdesc:a10c4508e5d2498979fe9060380d9ed44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a float sample value. <br /></td></tr>
<tr class="separator:a10c4508e5d2498979fe9060380d9ed44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c29c561e0966b087ac1353f88e23e" id="r_a478c29c561e0966b087ac1353f88e23e"><td class="memItemLeft" align="right" valign="top"><a id="a478c29c561e0966b087ac1353f88e23e" name="a478c29c561e0966b087ac1353f88e23e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampleText</b> (uint64_t sample, std::string &amp;value, uint64_t array_index) const =0</td></tr>
<tr class="memdesc:a478c29c561e0966b087ac1353f88e23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string sample value. <br /></td></tr>
<tr class="separator:a478c29c561e0966b087ac1353f88e23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c8fa4fc52f464bf33487dde3c8e493" id="r_a70c8fa4fc52f464bf33487dde3c8e493"><td class="memItemLeft" align="right" valign="top"><a id="a70c8fa4fc52f464bf33487dde3c8e493" name="a70c8fa4fc52f464bf33487dde3c8e493"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampleByteArray</b> (uint64_t sample, std::vector&lt; uint8_t &gt; &amp;value) const =0</td></tr>
<tr class="memdesc:a70c8fa4fc52f464bf33487dde3c8e493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte array sample value. <br /></td></tr>
<tr class="separator:a70c8fa4fc52f464bf33487dde3c8e493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1054f169e39eeeda91cee4ecf6e691f6" id="r_a1054f169e39eeeda91cee4ecf6e691f6"><td class="memItemLeft" align="right" valign="top"><a id="a1054f169e39eeeda91cee4ecf6e691f6" name="a1054f169e39eeeda91cee4ecf6e691f6"></a>
const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>channel_</b></td></tr>
<tr class="memdesc:a1054f169e39eeeda91cee4ecf6e691f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the channel (CN) block. <br /></td></tr>
<tr class="separator:a1054f169e39eeeda91cee4ecf6e691f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f58a595a2144a3c39f348fac323ba7" id="r_ab6f58a595a2144a3c39f348fac323ba7"><td class="memItemLeft" align="right" valign="top"><a id="ab6f58a595a2144a3c39f348fac323ba7" name="ab6f58a595a2144a3c39f348fac323ba7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_vlsd_data_</b> = true</td></tr>
<tr class="memdesc:ab6f58a595a2144a3c39f348fac323ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines if the VLSD bytes should be read. <br /></td></tr>
<tr class="separator:ab6f58a595a2144a3c39f348fac323ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07c03b2bf2ac617d28b11a182e41912" id="r_ae07c03b2bf2ac617d28b11a182e41912"><td class="memItemLeft" align="right" valign="top"><a id="ae07c03b2bf2ac617d28b11a182e41912" name="ae07c03b2bf2ac617d28b11a182e41912"></a>
std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>offset_list_</b></td></tr>
<tr class="memdesc:ae07c03b2bf2ac617d28b11a182e41912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for VLSD channels. <br /></td></tr>
<tr class="separator:ae07c03b2bf2ac617d28b11a182e41912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0252fcfee4667888d7b9c27b1305ad73" id="r_a0252fcfee4667888d7b9c27b1305ad73"><td class="memItemLeft" align="right" valign="top"><a id="a0252fcfee4667888d7b9c27b1305ad73" name="a0252fcfee4667888d7b9c27b1305ad73"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>valid_list_</b></td></tr>
<tr class="memdesc:a0252fcfee4667888d7b9c27b1305ad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of valid samples. <br /></td></tr>
<tr class="separator:a0252fcfee4667888d7b9c27b1305ad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmdf_1_1_i_sample_observer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classmdf_1_1_i_sample_observer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmdf_1_1_i_sample_observer.html">mdf::ISampleObserver</a></td></tr>
<tr class="memitem:a87722b22726b87c6f30e03958a193c57 inherit pro_attribs_classmdf_1_1_i_sample_observer" id="r_a87722b22726b87c6f30e03958a193c57"><td class="memItemLeft" align="right" valign="top">
std::set&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>record_id_list_</b></td></tr>
<tr class="memdesc:a87722b22726b87c6f30e03958a193c57 inherit pro_attribs_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of subscribed channel groups. <br /></td></tr>
<tr class="separator:a87722b22726b87c6f30e03958a193c57 inherit pro_attribs_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b62a5469fdaa2ec68af57ea0d9f4d9 inherit pro_attribs_classmdf_1_1_i_sample_observer" id="r_a12b62a5469fdaa2ec68af57ea0d9f4d9"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classmdf_1_1_i_data_group.html">IDataGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data_group_</b></td></tr>
<tr class="memdesc:a12b62a5469fdaa2ec68af57ea0d9f4d9 inherit pro_attribs_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the data group (DG) block. <br /></td></tr>
<tr class="separator:a12b62a5469fdaa2ec68af57ea0d9f4d9 inherit pro_attribs_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classmdf_1_1_i_sample_observer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_classmdf_1_1_i_sample_observer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmdf_1_1_i_sample_observer.html">mdf::ISampleObserver</a></td></tr>
<tr class="memitem:a97f0554517ca72e503543eb2e0efc236 inherit pub_attribs_classmdf_1_1_i_sample_observer" id="r_a97f0554517ca72e503543eb2e0efc236"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(uint64_t sample, uint64_t record_id, const std::vector&lt; uint8_t &gt; &amp;record)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_sample_observer.html#a97f0554517ca72e503543eb2e0efc236">DoOnSample</a></td></tr>
<tr class="memdesc:a97f0554517ca72e503543eb2e0efc236 inherit pub_attribs_classmdf_1_1_i_sample_observer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that is called if assigned.  <br /></td></tr>
<tr class="separator:a97f0554517ca72e503543eb2e0efc236 inherit pub_attribs_classmdf_1_1_i_sample_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main purpose for a channel observer is to store all channel samples for a channel. This object is used when reading data from a MDF file. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5b6e85bdf1a75b68d1c84a49c56da60" name="ae5b6e85bdf1a75b68d1c84a49c56da60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b6e85bdf1a75b68d1c84a49c56da60">&#9670;&#160;</a></span>ArraySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mdf::IChannelObserver::ArraySize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array size if the channel is an array channel. The function returns 1 if not is an array channel. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a164c91c7d6774c49a41d334c64668290" name="a164c91c7d6774c49a41d334c64668290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164c91c7d6774c49a41d334c64668290">&#9670;&#160;</a></span>Channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> &amp; mdf::IChannelObserver::Channel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the channel object associated with this observer. The channel is mostly needed to check if the channel is an array channel. Array channels are seldom used and are complex to handle. </p><dl class="section return"><dt>Returns</dt><dd>Returns the channel object. </dd></dl>

</div>
</div>
<a id="a819be1e44a252c08af1ae72b0815adba" name="a819be1e44a252c08af1ae72b0815adba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819be1e44a252c08af1ae72b0815adba">&#9670;&#160;</a></span>EngValueToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mdf::IChannelObserver::EngValueToString </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that convert a sample to a user friendly string. For non-array samples, the function is the same as GetChannelValue but for array sample a JSON array string is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON formatted string </dd></dl>

</div>
</div>
<a id="adb2e98dedf693b33943432a04dd88abc" name="adb2e98dedf693b33943432a04dd88abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e98dedf693b33943432a04dd88abc">&#9670;&#160;</a></span>GetChannelSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; mdf::IChannelObserver::GetChannelSamples </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all non-scaled sample values. Do not use this function for array channels. Use the <a class="el" href="#aff05a7e1b6542d5d7e73397bc657ecc4" title="Returns a vector of array channel values for a specific sample.">GetChannelValues()</a> function for array values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The destination sample list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of valid booleans. </dd></dl>

</div>
</div>
<a id="a4e6ca9903ce2e7236b1bea4d978256d2" name="a4e6ca9903ce2e7236b1bea4d978256d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6ca9903ce2e7236b1bea4d978256d2">&#9670;&#160;</a></span>GetChannelValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mdf::IChannelObserver::GetChannelValue </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (unscaled) so-called channel value for a specific sample. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample number (0..). </td></tr>
    <tr><td class="paramname">value</td><td>The channel value. </td></tr>
    <tr><td class="paramname">array_index</td><td>Optional array index if the channel is an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value is valid. </dd></dl>

</div>
</div>
<a id="aff05a7e1b6542d5d7e73397bc657ecc4" name="aff05a7e1b6542d5d7e73397bc657ecc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff05a7e1b6542d5d7e73397bc657ecc4">&#9670;&#160;</a></span>GetChannelValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; mdf::IChannelObserver::GetChannelValues </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is intended to be used on channel arrays. It returns all scaled array values for a sample. Note that the valid flags are return by the <a class="el" href="#a02428742a22bf2b210365160e0cfb498" title="Returns the sample to valid list.">GetValidList()</a> function.</p>
<p>The values vector doesn't need to be sized.</p>
<p>If used on non-array channels, it returns a vector of one values. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample index. </td></tr>
    <tr><td class="paramname">values</td><td>The destination vector of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vector of valid booleans. </dd></dl>

</div>
</div>
<a id="aaae998c473b76df6076b930f897b65fd" name="aaae998c473b76df6076b930f897b65fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae998c473b76df6076b930f897b65fd">&#9670;&#160;</a></span>GetEngSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; mdf::IChannelObserver::GetEngSamples </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all scaled sample values. Do not use this function for array channels. Use the <a class="el" href="#aff05a7e1b6542d5d7e73397bc657ecc4" title="Returns a vector of array channel values for a specific sample.">GetChannelValues()</a> function for array values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The destination sample list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of valid booleans. </dd></dl>

</div>
</div>
<a id="a18809112e05690a07e7e57ddb0d94807" name="a18809112e05690a07e7e57ddb0d94807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18809112e05690a07e7e57ddb0d94807">&#9670;&#160;</a></span>GetEngValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mdf::IChannelObserver::GetEngValue </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the engineering (scaled) value for a specific value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample number (0..). </td></tr>
    <tr><td class="paramname">value</td><td>The return value. </td></tr>
    <tr><td class="paramname">array_index</td><td>Optional array index if the channel is an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="adf6c0e8598ff26095f14a1f4cbed1de1" name="adf6c0e8598ff26095f14a1f4cbed1de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6c0e8598ff26095f14a1f4cbed1de1">&#9670;&#160;</a></span>GetEngValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; mdf::IChannelObserver::GetEngValues </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is intended to be used on channel arrays. It returns all scaled array values for a sample. Note that the valid flags are return by the GetValidList</p>
<p>If used on non-array channels, the value vector is of size 1. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample index. </td></tr>
    <tr><td class="paramname">values</td><td>List of returning array scaled values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of valid/invalid flags (boolean). </dd></dl>

</div>
</div>
<a id="ab4af7d3ece557b14f80a5513193afd1e" name="ab4af7d3ece557b14f80a5513193afd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af7d3ece557b14f80a5513193afd1e">&#9670;&#160;</a></span>GetOffsetList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; uint64_t &gt; &amp; mdf::IChannelObserver::GetOffsetList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This VLSD offset list is only needed when setting the ReadVLSDData() property to false. By only reading the offset list, the VLSD bytes can be read later as sample by sample or as a range of VSLD bytes. THis read saves primary memory and is much faster if only some samples are needed. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a964af22898be38655cf46d965471ed4a" name="a964af22898be38655cf46d965471ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964af22898be38655cf46d965471ed4a">&#9670;&#160;</a></span>ReadVlsdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannelObserver::ReadVlsdData </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>read_vlsd_data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reading VLSD raw data may fail if there is no room for the bytes in the primary memory. Normally is this property normally set to true but if set to false, only the offset into the VLSD block is read. This call should be followed buy one or more call to the MdfWriter::ReadVlsdData() function. By this, only partial samples can be read in and thus saving primary memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_vlsd_data</td><td>Set to false if VLSD bytes shouldn't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd31f098621d481f001509ca8b3b4e76" name="abd31f098621d481f001509ca8b3b4e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd31f098621d481f001509ca8b3b4e76">&#9670;&#160;</a></span>Shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; mdf::IChannelObserver::Shape </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to size an array in an external library. The Eigen and XTensor C++ libraries are typical</p>
<dl class="section return"><dt>Returns</dt><dd>Shape vector that describes an array dimension. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mdf/<a class="el" href="ichannelobserver_8h_source.html">ichannelobserver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
