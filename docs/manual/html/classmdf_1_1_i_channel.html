<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MDF Lib: mdf::IChannel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="utillib.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MDF Lib<span id="projectnumber">&#160;2.2</span>
   </div>
   <div id="projectbrief">Interface against MDF 3/4 files</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemdf.html">mdf</a></li><li class="navelem"><a class="el" href="classmdf_1_1_i_channel.html">IChannel</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmdf_1_1_i_channel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mdf::IChannel Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Defines a MDF channel (CN) block.  
</p>

<p><code>#include &lt;<a class="el" href="ichannel_8h_source.html">ichannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdf::IChannel:</div>
<div class="dyncontent">
<div class="center"><img src="classmdf_1_1_i_channel__inherit__graph.png" border="0" usemap="#amdf_1_1_i_channel_inherit__map" alt="Inheritance graph"/></div>
<map name="amdf_1_1_i_channel_inherit__map" id="amdf_1_1_i_channel_inherit__map">
<area shape="rect" title="Defines a MDF channel (CN) block." alt="" coords="5,79,107,104"/>
<area shape="rect" href="classmdf_1_1_i_block.html" title="Base class for all MDF blocks." alt="" coords="13,5,99,31"/>
<area shape="poly" title=" " alt="" coords="59,44,59,79,53,79,53,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdf::IChannel:</div>
<div class="dyncontent">
<div class="center"><img src="classmdf_1_1_i_channel__coll__graph.png" border="0" usemap="#amdf_1_1_i_channel_coll__map" alt="Collaboration graph"/></div>
<map name="amdf_1_1_i_channel_coll__map" id="amdf_1_1_i_channel_coll__map">
<area shape="rect" title="Defines a MDF channel (CN) block." alt="" coords="5,79,107,104"/>
<area shape="rect" href="classmdf_1_1_i_block.html" title="Base class for all MDF blocks." alt="" coords="13,5,99,31"/>
<area shape="poly" title=" " alt="" coords="59,44,59,79,53,79,53,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad0d31706ee80b34c1dc5007076c4134d" id="r_ad0d31706ee80b34c1dc5007076c4134d"><td class="memItemLeft" align="right" valign="top"><a id="ad0d31706ee80b34c1dc5007076c4134d" name="ad0d31706ee80b34c1dc5007076c4134d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:ad0d31706ee80b34c1dc5007076c4134d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets channel name. <br /></td></tr>
<tr class="separator:ad0d31706ee80b34c1dc5007076c4134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df3c83feac51d9d8ac40821e764ceae" id="r_a6df3c83feac51d9d8ac40821e764ceae"><td class="memItemLeft" align="right" valign="top"><a id="a6df3c83feac51d9d8ac40821e764ceae" name="a6df3c83feac51d9d8ac40821e764ceae"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b> () const =0</td></tr>
<tr class="memdesc:a6df3c83feac51d9d8ac40821e764ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns channel name. <br /></td></tr>
<tr class="separator:a6df3c83feac51d9d8ac40821e764ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32c29ab60072244fab0ebaa132e3bf3" id="r_af32c29ab60072244fab0ebaa132e3bf3"><td class="memItemLeft" align="right" valign="top"><a id="af32c29ab60072244fab0ebaa132e3bf3" name="af32c29ab60072244fab0ebaa132e3bf3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DisplayName</b> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:af32c29ab60072244fab0ebaa132e3bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets display name. <br /></td></tr>
<tr class="separator:af32c29ab60072244fab0ebaa132e3bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f066ad1c8b25e6f24e38031ea6c50e" id="r_aa6f066ad1c8b25e6f24e38031ea6c50e"><td class="memItemLeft" align="right" valign="top"><a id="aa6f066ad1c8b25e6f24e38031ea6c50e" name="aa6f066ad1c8b25e6f24e38031ea6c50e"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>DisplayName</b> () const =0</td></tr>
<tr class="memdesc:aa6f066ad1c8b25e6f24e38031ea6c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display name. <br /></td></tr>
<tr class="separator:aa6f066ad1c8b25e6f24e38031ea6c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3b07e3da2b4e625f0a84545b963e7" id="r_a8cd3b07e3da2b4e625f0a84545b963e7"><td class="memItemLeft" align="right" valign="top"><a id="a8cd3b07e3da2b4e625f0a84545b963e7" name="a8cd3b07e3da2b4e625f0a84545b963e7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Description</b> (const std::string &amp;description)=0</td></tr>
<tr class="memdesc:a8cd3b07e3da2b4e625f0a84545b963e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description. <br /></td></tr>
<tr class="separator:a8cd3b07e3da2b4e625f0a84545b963e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657ee3a93c646a0ca1faea8d62488a8" id="r_a1657ee3a93c646a0ca1faea8d62488a8"><td class="memItemLeft" align="right" valign="top"><a id="a1657ee3a93c646a0ca1faea8d62488a8" name="a1657ee3a93c646a0ca1faea8d62488a8"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Description</b> () const =0</td></tr>
<tr class="memdesc:a1657ee3a93c646a0ca1faea8d62488a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description. <br /></td></tr>
<tr class="separator:a1657ee3a93c646a0ca1faea8d62488a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a3b88bc8d1a5844d04289e89e826c4" id="r_a36a3b88bc8d1a5844d04289e89e826c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a3b88bc8d1a5844d04289e89e826c4">Unit</a> (const std::string &amp;unit)=0</td></tr>
<tr class="memdesc:a36a3b88bc8d1a5844d04289e89e826c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets unit string or or the MIME text string.  <br /></td></tr>
<tr class="separator:a36a3b88bc8d1a5844d04289e89e826c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4d05b309f1fdf0428eb1d381887df" id="r_ac0d4d05b309f1fdf0428eb1d381887df"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d4d05b309f1fdf0428eb1d381887df">Unit</a> () const =0</td></tr>
<tr class="memdesc:ac0d4d05b309f1fdf0428eb1d381887df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit string or the MIME content type string.  <br /></td></tr>
<tr class="separator:ac0d4d05b309f1fdf0428eb1d381887df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aae84ad11d364a7f6a513e46705551" id="r_a62aae84ad11d364a7f6a513e46705551"><td class="memItemLeft" align="right" valign="top"><a id="a62aae84ad11d364a7f6a513e46705551" name="a62aae84ad11d364a7f6a513e46705551"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Flags</b> (uint32_t flags)</td></tr>
<tr class="memdesc:a62aae84ad11d364a7f6a513e46705551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets channel flags. Flags are defined in the <a class="el" href="namespacemdf_1_1_cn_flag.html" title="Channel flags. See also IChannel::Flags().">CnFlag</a> namespace <br  />
 <br /></td></tr>
<tr class="separator:a62aae84ad11d364a7f6a513e46705551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee04da646dd8f0449e629dbe3e0b04" id="r_afdee04da646dd8f0449e629dbe3e0b04"><td class="memItemLeft" align="right" valign="top"><a id="afdee04da646dd8f0449e629dbe3e0b04" name="afdee04da646dd8f0449e629dbe3e0b04"></a>
virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>Flags</b> () const</td></tr>
<tr class="memdesc:afdee04da646dd8f0449e629dbe3e0b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel flags are defined in the <a class="el" href="namespacemdf_1_1_cn_flag.html" title="Channel flags. See also IChannel::Flags().">CnFlag</a> namespace <br  />
 <br /></td></tr>
<tr class="separator:afdee04da646dd8f0449e629dbe3e0b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40cab295bfde6ec373bfecfaadadc45" id="r_ac40cab295bfde6ec373bfecfaadadc45"><td class="memItemLeft" align="right" valign="top"><a id="ac40cab295bfde6ec373bfecfaadadc45" name="ac40cab295bfde6ec373bfecfaadadc45"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsUnitValid</b> () const =0</td></tr>
<tr class="memdesc:ac40cab295bfde6ec373bfecfaadadc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if unit exists. <br /></td></tr>
<tr class="separator:ac40cab295bfde6ec373bfecfaadadc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5314d56e61ffc2b736ca9b69a6050229" id="r_a5314d56e61ffc2b736ca9b69a6050229"><td class="memItemLeft" align="right" valign="top"><a id="a5314d56e61ffc2b736ca9b69a6050229" name="a5314d56e61ffc2b736ca9b69a6050229"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> (<a class="el" href="namespacemdf.html#aada23089f38b2f9a6a017ec2b1ec937d">ChannelType</a> type)=0</td></tr>
<tr class="memdesc:a5314d56e61ffc2b736ca9b69a6050229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of channel. <br /></td></tr>
<tr class="separator:a5314d56e61ffc2b736ca9b69a6050229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19e08b1f8f20f7036e3ea43775d7a1" id="r_a5f19e08b1f8f20f7036e3ea43775d7a1"><td class="memItemLeft" align="right" valign="top"><a id="a5f19e08b1f8f20f7036e3ea43775d7a1" name="a5f19e08b1f8f20f7036e3ea43775d7a1"></a>
virtual <a class="el" href="namespacemdf.html#aada23089f38b2f9a6a017ec2b1ec937d">ChannelType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> () const =0</td></tr>
<tr class="memdesc:a5f19e08b1f8f20f7036e3ea43775d7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of channel. <br /></td></tr>
<tr class="separator:a5f19e08b1f8f20f7036e3ea43775d7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575bb123eaad4903954941aab17d2b14" id="r_a575bb123eaad4903954941aab17d2b14"><td class="memItemLeft" align="right" valign="top"><a id="a575bb123eaad4903954941aab17d2b14" name="a575bb123eaad4903954941aab17d2b14"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Sync</b> (<a class="el" href="namespacemdf.html#a97db9dc7397318bc42aa8ba07f1880df">ChannelSyncType</a> type)</td></tr>
<tr class="memdesc:a575bb123eaad4903954941aab17d2b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of sync. <br /></td></tr>
<tr class="separator:a575bb123eaad4903954941aab17d2b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c4561396862770e5b829201a73daf4" id="r_ae7c4561396862770e5b829201a73daf4"><td class="memItemLeft" align="right" valign="top"><a id="ae7c4561396862770e5b829201a73daf4" name="ae7c4561396862770e5b829201a73daf4"></a>
virtual <a class="el" href="namespacemdf.html#a97db9dc7397318bc42aa8ba07f1880df">ChannelSyncType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sync</b> () const</td></tr>
<tr class="memdesc:ae7c4561396862770e5b829201a73daf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of sync. <br /></td></tr>
<tr class="separator:ae7c4561396862770e5b829201a73daf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9c9f876d464cdd131025cf55e0868f" id="r_acc9c9f876d464cdd131025cf55e0868f"><td class="memItemLeft" align="right" valign="top"><a id="acc9c9f876d464cdd131025cf55e0868f" name="acc9c9f876d464cdd131025cf55e0868f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DataType</b> (<a class="el" href="namespacemdf.html#ae7ad63cc2b6ab8756d7149ae96453722">ChannelDataType</a> type)=0</td></tr>
<tr class="memdesc:acc9c9f876d464cdd131025cf55e0868f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data type. <br /></td></tr>
<tr class="separator:acc9c9f876d464cdd131025cf55e0868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e9af5462ff48caa462d775d6ff830" id="r_a931e9af5462ff48caa462d775d6ff830"><td class="memItemLeft" align="right" valign="top"><a id="a931e9af5462ff48caa462d775d6ff830" name="a931e9af5462ff48caa462d775d6ff830"></a>
virtual <a class="el" href="namespacemdf.html#ae7ad63cc2b6ab8756d7149ae96453722">ChannelDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataType</b> () const =0</td></tr>
<tr class="memdesc:a931e9af5462ff48caa462d775d6ff830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type. <br /></td></tr>
<tr class="separator:a931e9af5462ff48caa462d775d6ff830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8025c0cf92b1f5e3ecf4486a38b63509" id="r_a8025c0cf92b1f5e3ecf4486a38b63509"><td class="memItemLeft" align="right" valign="top"><a id="a8025c0cf92b1f5e3ecf4486a38b63509" name="a8025c0cf92b1f5e3ecf4486a38b63509"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DataBytes</b> (uint64_t nof_bytes)=0</td></tr>
<tr class="memdesc:a8025c0cf92b1f5e3ecf4486a38b63509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data size (bytes) <br /></td></tr>
<tr class="separator:a8025c0cf92b1f5e3ecf4486a38b63509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d764d8bf7f80a12bdf26057f414c2e" id="r_a59d764d8bf7f80a12bdf26057f414c2e"><td class="memItemLeft" align="right" valign="top"><a id="a59d764d8bf7f80a12bdf26057f414c2e" name="a59d764d8bf7f80a12bdf26057f414c2e"></a>
virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DataBytes</b> () const =0</td></tr>
<tr class="memdesc:a59d764d8bf7f80a12bdf26057f414c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data size (bytes);. <br /></td></tr>
<tr class="separator:a59d764d8bf7f80a12bdf26057f414c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f2799e0dcb124e1968302cf9123102" id="r_ae3f2799e0dcb124e1968302cf9123102"><td class="memItemLeft" align="right" valign="top"><a id="ae3f2799e0dcb124e1968302cf9123102" name="ae3f2799e0dcb124e1968302cf9123102"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Decimals</b> (uint8_t precision)</td></tr>
<tr class="memdesc:ae3f2799e0dcb124e1968302cf9123102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of decimals (floating points only) <br  />
 <br /></td></tr>
<tr class="separator:ae3f2799e0dcb124e1968302cf9123102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeee4343e58cc7d9beb21c236ed95e8" id="r_a8eeee4343e58cc7d9beb21c236ed95e8"><td class="memItemLeft" align="right" valign="top"><a id="a8eeee4343e58cc7d9beb21c236ed95e8" name="a8eeee4343e58cc7d9beb21c236ed95e8"></a>
virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>Decimals</b> () const =0</td></tr>
<tr class="memdesc:a8eeee4343e58cc7d9beb21c236ed95e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of decimals (floating points) <br  />
 <br /></td></tr>
<tr class="separator:a8eeee4343e58cc7d9beb21c236ed95e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddb199531ebfccb20a7f599681a36a1" id="r_a2ddb199531ebfccb20a7f599681a36a1"><td class="memItemLeft" align="right" valign="top"><a id="a2ddb199531ebfccb20a7f599681a36a1" name="a2ddb199531ebfccb20a7f599681a36a1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDecimalUsed</b> () const =0</td></tr>
<tr class="memdesc:a2ddb199531ebfccb20a7f599681a36a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if decimals is used <br  />
 <br /></td></tr>
<tr class="separator:a2ddb199531ebfccb20a7f599681a36a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c144d60e2b9fccff15ff910ac8e619" id="r_a05c144d60e2b9fccff15ff910ac8e619"><td class="memItemLeft" align="right" valign="top"><a id="a05c144d60e2b9fccff15ff910ac8e619" name="a05c144d60e2b9fccff15ff910ac8e619"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b> (double min, double max)</td></tr>
<tr class="memdesc:a05c144d60e2b9fccff15ff910ac8e619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ranges. <br  />
 <br /></td></tr>
<tr class="separator:a05c144d60e2b9fccff15ff910ac8e619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2bd21f197b46d07015012a48dee3f8" id="r_a8a2bd21f197b46d07015012a48dee3f8"><td class="memItemLeft" align="right" valign="top"><a id="a8a2bd21f197b46d07015012a48dee3f8" name="a8a2bd21f197b46d07015012a48dee3f8"></a>
virtual std::optional&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b> () const</td></tr>
<tr class="memdesc:a8a2bd21f197b46d07015012a48dee3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ranges. <br  />
 <br /></td></tr>
<tr class="separator:a8a2bd21f197b46d07015012a48dee3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75df87353aaceb8ca1d809a99df7c17" id="r_ab75df87353aaceb8ca1d809a99df7c17"><td class="memItemLeft" align="right" valign="top"><a id="ab75df87353aaceb8ca1d809a99df7c17" name="ab75df87353aaceb8ca1d809a99df7c17"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Limit</b> (double min, double max)</td></tr>
<tr class="memdesc:ab75df87353aaceb8ca1d809a99df7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the limits. <br  />
 <br /></td></tr>
<tr class="separator:ab75df87353aaceb8ca1d809a99df7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e8995a869945f0cfd373350d2a3adc" id="r_a06e8995a869945f0cfd373350d2a3adc"><td class="memItemLeft" align="right" valign="top"><a id="a06e8995a869945f0cfd373350d2a3adc" name="a06e8995a869945f0cfd373350d2a3adc"></a>
virtual std::optional&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Limit</b> () const</td></tr>
<tr class="memdesc:a06e8995a869945f0cfd373350d2a3adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limits. <br  />
 <br /></td></tr>
<tr class="separator:a06e8995a869945f0cfd373350d2a3adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86276080181f8cc33cc182c4bf5bdb5" id="r_af86276080181f8cc33cc182c4bf5bdb5"><td class="memItemLeft" align="right" valign="top"><a id="af86276080181f8cc33cc182c4bf5bdb5" name="af86276080181f8cc33cc182c4bf5bdb5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ExtLimit</b> (double min, double max)</td></tr>
<tr class="memdesc:af86276080181f8cc33cc182c4bf5bdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extended limits. <br  />
 <br /></td></tr>
<tr class="separator:af86276080181f8cc33cc182c4bf5bdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59baaa5abd9c2077fe0c9c2d1c0cd9d" id="r_af59baaa5abd9c2077fe0c9c2d1c0cd9d"><td class="memItemLeft" align="right" valign="top"><a id="af59baaa5abd9c2077fe0c9c2d1c0cd9d" name="af59baaa5abd9c2077fe0c9c2d1c0cd9d"></a>
virtual std::optional&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExtLimit</b> () const</td></tr>
<tr class="memdesc:af59baaa5abd9c2077fe0c9c2d1c0cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extended limits. <br  />
 <br /></td></tr>
<tr class="separator:af59baaa5abd9c2077fe0c9c2d1c0cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541ee7e29a97be10c4bdf0fde3382e9f" id="r_a541ee7e29a97be10c4bdf0fde3382e9f"><td class="memItemLeft" align="right" valign="top"><a id="a541ee7e29a97be10c4bdf0fde3382e9f" name="a541ee7e29a97be10c4bdf0fde3382e9f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SamplingRate</b> (double sampling_rate)=0</td></tr>
<tr class="memdesc:a541ee7e29a97be10c4bdf0fde3382e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the sample rate (s). This is a MDF 3 feature. <br  />
 <br /></td></tr>
<tr class="separator:a541ee7e29a97be10c4bdf0fde3382e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198df1edd0fbeeabd25c405841ab4328" id="r_a198df1edd0fbeeabd25c405841ab4328"><td class="memItemLeft" align="right" valign="top"><a id="a198df1edd0fbeeabd25c405841ab4328" name="a198df1edd0fbeeabd25c405841ab4328"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>SamplingRate</b> () const =0</td></tr>
<tr class="memdesc:a198df1edd0fbeeabd25c405841ab4328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample rate (s). This is a MDF 3 feature. <br  />
 <br /></td></tr>
<tr class="separator:a198df1edd0fbeeabd25c405841ab4328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232823d55efef433e246ee85d0c73dc4" id="r_a232823d55efef433e246ee85d0c73dc4"><td class="memItemLeft" align="right" valign="top"><a id="a232823d55efef433e246ee85d0c73dc4" name="a232823d55efef433e246ee85d0c73dc4"></a>
virtual <a class="el" href="classmdf_1_1_i_source_information.html">ISourceInformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>SourceInformation</b> () const</td></tr>
<tr class="memdesc:a232823d55efef433e246ee85d0c73dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source information, if any. <br /></td></tr>
<tr class="separator:a232823d55efef433e246ee85d0c73dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cb869f6486173eacf7a45fec6dffd0" id="r_a29cb869f6486173eacf7a45fec6dffd0"><td class="memItemLeft" align="right" valign="top"><a id="a29cb869f6486173eacf7a45fec6dffd0" name="a29cb869f6486173eacf7a45fec6dffd0"></a>
virtual <a class="el" href="classmdf_1_1_i_source_information.html">ISourceInformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSourceInformation</b> ()</td></tr>
<tr class="memdesc:a29cb869f6486173eacf7a45fec6dffd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a source information block. <br /></td></tr>
<tr class="separator:a29cb869f6486173eacf7a45fec6dffd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a9a7199ae62203607ee304435b905" id="r_a115a9a7199ae62203607ee304435b905"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmdf_1_1_i_channel_array.html">IChannelArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115a9a7199ae62203607ee304435b905">ChannelArray</a> () const</td></tr>
<tr class="memdesc:a115a9a7199ae62203607ee304435b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the channel array object if any exist in this channel.  <br /></td></tr>
<tr class="separator:a115a9a7199ae62203607ee304435b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b86497bd0b22bfc1e892e98fbd8a3b2" id="r_a8b86497bd0b22bfc1e892e98fbd8a3b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmdf_1_1_i_channel_array.html">IChannelArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b86497bd0b22bfc1e892e98fbd8a3b2">CreateChannelArray</a> ()</td></tr>
<tr class="memdesc:a8b86497bd0b22bfc1e892e98fbd8a3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or returns an existing channel array (CA) block.  <br /></td></tr>
<tr class="separator:a8b86497bd0b22bfc1e892e98fbd8a3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf293bd067e1481130dc8adc465edd9" id="r_acaf293bd067e1481130dc8adc465edd9"><td class="memItemLeft" align="right" valign="top"><a id="acaf293bd067e1481130dc8adc465edd9" name="acaf293bd067e1481130dc8adc465edd9"></a>
virtual <a class="el" href="classmdf_1_1_i_channel_conversion.html">IChannelConversion</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ChannelConversion</b> () const =0</td></tr>
<tr class="memdesc:acaf293bd067e1481130dc8adc465edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conversion block, if any. <br /></td></tr>
<tr class="separator:acaf293bd067e1481130dc8adc465edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671a222070b00fc61e7b65795cbb477f" id="r_a671a222070b00fc61e7b65795cbb477f"><td class="memItemLeft" align="right" valign="top"><a id="a671a222070b00fc61e7b65795cbb477f" name="a671a222070b00fc61e7b65795cbb477f"></a>
virtual <a class="el" href="classmdf_1_1_i_channel_conversion.html">IChannelConversion</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CreateChannelConversion</b> ()=0</td></tr>
<tr class="memdesc:a671a222070b00fc61e7b65795cbb477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a conversion block. <br /></td></tr>
<tr class="separator:a671a222070b00fc61e7b65795cbb477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29f9258dbf58727f6e556ecfde2bbce" id="r_ad29f9258dbf58727f6e556ecfde2bbce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad29f9258dbf58727f6e556ecfde2bbce">CreateChannelComposition</a> ()=0</td></tr>
<tr class="memdesc:ad29f9258dbf58727f6e556ecfde2bbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a composition channel.  <br /></td></tr>
<tr class="separator:ad29f9258dbf58727f6e556ecfde2bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864a22be7a831f2d9473292fb16827f7" id="r_a864a22be7a831f2d9473292fb16827f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864a22be7a831f2d9473292fb16827f7">CreateChannelComposition</a> (const std::string_view &amp;name)</td></tr>
<tr class="memdesc:a864a22be7a831f2d9473292fb16827f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a composition channel with a specific name or returns an existing channel.  <br /></td></tr>
<tr class="separator:a864a22be7a831f2d9473292fb16827f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dd687896052c0425910967f077286b" id="r_a76dd687896052c0425910967f077286b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76dd687896052c0425910967f077286b">ChannelCompositions</a> ()=0</td></tr>
<tr class="memdesc:a76dd687896052c0425910967f077286b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a composition channel.  <br /></td></tr>
<tr class="separator:a76dd687896052c0425910967f077286b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ac9c2409022d3d20ebba56f74678cc" id="r_aa8ac9c2409022d3d20ebba56f74678cc"><td class="memItemLeft" align="right" valign="top"><a id="aa8ac9c2409022d3d20ebba56f74678cc" name="aa8ac9c2409022d3d20ebba56f74678cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNumber</b> () const</td></tr>
<tr class="memdesc:aa8ac9c2409022d3d20ebba56f74678cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the channel is a number. <br /></td></tr>
<tr class="separator:aa8ac9c2409022d3d20ebba56f74678cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f6fab8b44865e4e02c757327a29295" id="r_a75f6fab8b44865e4e02c757327a29295"><td class="memItemLeft" align="right" valign="top"><a id="a75f6fab8b44865e4e02c757327a29295" name="a75f6fab8b44865e4e02c757327a29295"></a>
virtual <a class="el" href="classmdf_1_1_i_meta_data.html">IMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CreateMetaData</b> ()</td></tr>
<tr class="memdesc:a75f6fab8b44865e4e02c757327a29295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a metadata (MD) block. <br /></td></tr>
<tr class="separator:a75f6fab8b44865e4e02c757327a29295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e3e0929ee473830adeb4ea2640cdaa" id="r_a68e3e0929ee473830adeb4ea2640cdaa"><td class="memItemLeft" align="right" valign="top"><a id="a68e3e0929ee473830adeb4ea2640cdaa" name="a68e3e0929ee473830adeb4ea2640cdaa"></a>
virtual <a class="el" href="classmdf_1_1_i_meta_data.html">IMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MetaData</b> () const</td></tr>
<tr class="memdesc:a68e3e0929ee473830adeb4ea2640cdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta-data (MD) block if it exist. <br /></td></tr>
<tr class="separator:a68e3e0929ee473830adeb4ea2640cdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65be17a489e6188f0974084ba306326" id="r_ab65be17a489e6188f0974084ba306326"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab65be17a489e6188f0974084ba306326">AddAttachmentReference</a> (const <a class="el" href="classmdf_1_1_i_attachment.html">IAttachment</a> *attachment)</td></tr>
<tr class="memdesc:ab65be17a489e6188f0974084ba306326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attachment reference to the channel.  <br /></td></tr>
<tr class="separator:ab65be17a489e6188f0974084ba306326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b1815c3a1c78ff8318bbadabf97652" id="r_a30b1815c3a1c78ff8318bbadabf97652"><td class="memItemLeft" align="right" valign="top"><a id="a30b1815c3a1c78ff8318bbadabf97652" name="a30b1815c3a1c78ff8318bbadabf97652"></a>
virtual std::vector&lt; const <a class="el" href="classmdf_1_1_i_attachment.html">IAttachment</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AttachmentList</b> () const</td></tr>
<tr class="memdesc:a30b1815c3a1c78ff8318bbadabf97652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of attachment pointers. <br /></td></tr>
<tr class="separator:a30b1815c3a1c78ff8318bbadabf97652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0097710fe52be6fa446944cd9f126bf" id="r_af0097710fe52be6fa446944cd9f126bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0097710fe52be6fa446944cd9f126bf">VlsdRecordId</a> (uint64_t record_id) const</td></tr>
<tr class="memdesc:af0097710fe52be6fa446944cd9f126bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the VLSD record id.  <br /></td></tr>
<tr class="separator:af0097710fe52be6fa446944cd9f126bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f93d53a8257129fbf322861c4b002c" id="r_a34f93d53a8257129fbf322861c4b002c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f93d53a8257129fbf322861c4b002c">VlsdRecordId</a> () const</td></tr>
<tr class="memdesc:a34f93d53a8257129fbf322861c4b002c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VLSD record id.  <br /></td></tr>
<tr class="separator:a34f93d53a8257129fbf322861c4b002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af516e447a9e2bb6a7b1e7b46e7257525" id="r_af516e447a9e2bb6a7b1e7b46e7257525"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af516e447a9e2bb6a7b1e7b46e7257525"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af516e447a9e2bb6a7b1e7b46e7257525">GetChannelValue</a> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, T &amp;dest, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:af516e447a9e2bb6a7b1e7b46e7257525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse out the channel value from a data record.  <br /></td></tr>
<tr class="separator:af516e447a9e2bb6a7b1e7b46e7257525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f02ecc9cf3760267c95b7eb4e1868d8" id="r_a0f02ecc9cf3760267c95b7eb4e1868d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f02ecc9cf3760267c95b7eb4e1868d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f02ecc9cf3760267c95b7eb4e1868d8">SetChannelValue</a> (const T &amp;value, bool valid=true, uint64_t array_index=0)</td></tr>
<tr class="memdesc:a0f02ecc9cf3760267c95b7eb4e1868d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a channel value.  <br /></td></tr>
<tr class="separator:a0f02ecc9cf3760267c95b7eb4e1868d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694470ca2821905f1b957a72a90f0f9" id="r_ad694470ca2821905f1b957a72a90f0f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad694470ca2821905f1b957a72a90f0f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad694470ca2821905f1b957a72a90f0f9">SetChannelValues</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:ad694470ca2821905f1b957a72a90f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets channel array values.  <br /></td></tr>
<tr class="separator:ad694470ca2821905f1b957a72a90f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7a28ee965b4121891d76ebbeecee14" id="r_a3e7a28ee965b4121891d76ebbeecee14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e7a28ee965b4121891d76ebbeecee14">GetUnsignedValue</a> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, uint64_t &amp;dest, uint64_t array_index=0) const</td></tr>
<tr class="memdesc:a3e7a28ee965b4121891d76ebbeecee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used function mainly for fetching VLSD index values.  <br /></td></tr>
<tr class="separator:a3e7a28ee965b4121891d76ebbeecee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3136a15e15cd5023c26d6b6fa2b79790" id="r_a3136a15e15cd5023c26d6b6fa2b79790"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3136a15e15cd5023c26d6b6fa2b79790">GetTextValue</a> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, std::string &amp;dest) const</td></tr>
<tr class="memdesc:a3136a15e15cd5023c26d6b6fa2b79790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used function mainly for fetching VLSD text values.  <br /></td></tr>
<tr class="separator:a3136a15e15cd5023c26d6b6fa2b79790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a5529d183edeb6b881c791f3a3c451" id="r_a33a5529d183edeb6b881c791f3a3c451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33a5529d183edeb6b881c791f3a3c451">SetTimestamp</a> (double timestamp, std::vector&lt; uint8_t &gt; &amp;record_buffer) const</td></tr>
<tr class="memdesc:a33a5529d183edeb6b881c791f3a3c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function change the supplied records time channel value.  <br /></td></tr>
<tr class="separator:a33a5529d183edeb6b881c791f3a3c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b39d985b2153dd0bd1773489f7837c" id="r_a92b39d985b2153dd0bd1773489f7837c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b39d985b2153dd0bd1773489f7837c">BitCount</a> (uint32_t bits)=0</td></tr>
<tr class="memdesc:a92b39d985b2153dd0bd1773489f7837c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of data in bits.  <br /></td></tr>
<tr class="separator:a92b39d985b2153dd0bd1773489f7837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d277c71bc001ee8e26edd55e96a56" id="r_a580d277c71bc001ee8e26edd55e96a56"><td class="memItemLeft" align="right" valign="top"><a id="a580d277c71bc001ee8e26edd55e96a56" name="a580d277c71bc001ee8e26edd55e96a56"></a>
virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>BitCount</b> () const =0</td></tr>
<tr class="memdesc:a580d277c71bc001ee8e26edd55e96a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data size in number of bits. <br /></td></tr>
<tr class="separator:a580d277c71bc001ee8e26edd55e96a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e43155f97b7e9faab958be1b52832" id="r_aa38e43155f97b7e9faab958be1b52832"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38e43155f97b7e9faab958be1b52832">BitOffset</a> (uint16_t bits)=0</td></tr>
<tr class="memdesc:aa38e43155f97b7e9faab958be1b52832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the offset to data in bits.  <br /></td></tr>
<tr class="separator:aa38e43155f97b7e9faab958be1b52832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3f5cb61e6e8ec7b42e6bb1571a87b3" id="r_aab3f5cb61e6e8ec7b42e6bb1571a87b3"><td class="memItemLeft" align="right" valign="top"><a id="aab3f5cb61e6e8ec7b42e6bb1571a87b3" name="aab3f5cb61e6e8ec7b42e6bb1571a87b3"></a>
virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>BitOffset</b> () const =0</td></tr>
<tr class="memdesc:aab3f5cb61e6e8ec7b42e6bb1571a87b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns offset to data (0..7). <br /></td></tr>
<tr class="separator:aab3f5cb61e6e8ec7b42e6bb1571a87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f25048931c7687984347867a06129f6" id="r_a5f25048931c7687984347867a06129f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f25048931c7687984347867a06129f6">ByteOffset</a> (uint32_t bytes)=0</td></tr>
<tr class="memdesc:a5f25048931c7687984347867a06129f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the byte offset in record to to data.  <br /></td></tr>
<tr class="separator:a5f25048931c7687984347867a06129f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf5ebecaef52c6a745e095256f8fe4" id="r_a3ebf5ebecaef52c6a745e095256f8fe4"><td class="memItemLeft" align="right" valign="top"><a id="a3ebf5ebecaef52c6a745e095256f8fe4" name="a3ebf5ebecaef52c6a745e095256f8fe4"></a>
virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ByteOffset</b> () const =0</td></tr>
<tr class="memdesc:a3ebf5ebecaef52c6a745e095256f8fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte offset to data in the record. <br /></td></tr>
<tr class="separator:a3ebf5ebecaef52c6a745e095256f8fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3c1efa16f7e760c3079ad6f2f1c3cf" id="r_a0f3c1efa16f7e760c3079ad6f2f1c3cf"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmdf_1_1_i_channel_group.html">IChannelGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3c1efa16f7e760c3079ad6f2f1c3cf">ChannelGroup</a> () const =0</td></tr>
<tr class="memdesc:a0f3c1efa16f7e760c3079ad6f2f1c3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that returns its channel group.  <br /></td></tr>
<tr class="separator:a0f3c1efa16f7e760c3079ad6f2f1c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258517eee06f2275d4edc29f6e92268f" id="r_a258517eee06f2275d4edc29f6e92268f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a258517eee06f2275d4edc29f6e92268f">RecordId</a> () const</td></tr>
<tr class="memdesc:a258517eee06f2275d4edc29f6e92268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns th channel group (CG) record ID.  <br /></td></tr>
<tr class="separator:a258517eee06f2275d4edc29f6e92268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5a405f19fb593d8ec38007ec401870" id="r_a1f5a405f19fb593d8ec38007ec401870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f5a405f19fb593d8ec38007ec401870">CalculateMasterTime</a> (bool calculate_master)</td></tr>
<tr class="memdesc:a1f5a405f19fb593d8ec38007ec401870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines if the master channel time should be calculated or not.  <br /></td></tr>
<tr class="separator:a1f5a405f19fb593d8ec38007ec401870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa216dc859b5cf5c3f602d21e83c4f6d" id="r_afa216dc859b5cf5c3f602d21e83c4f6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa216dc859b5cf5c3f602d21e83c4f6d">CalculateMasterTime</a> () const</td></tr>
<tr class="memdesc:afa216dc859b5cf5c3f602d21e83c4f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines if the master channel time is calculated or user defined.  <br /></td></tr>
<tr class="separator:afa216dc859b5cf5c3f602d21e83c4f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128de0bc7aa39d1b877481bb4216d410" id="r_a128de0bc7aa39d1b877481bb4216d410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128de0bc7aa39d1b877481bb4216d410">ArraySize</a> (uint64_t array_size)</td></tr>
<tr class="memdesc:a128de0bc7aa39d1b877481bb4216d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the array size for the channel.  <br /></td></tr>
<tr class="separator:a128de0bc7aa39d1b877481bb4216d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16500cdb878b302e69fdc68edd8aa49" id="r_ac16500cdb878b302e69fdc68edd8aa49"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac16500cdb878b302e69fdc68edd8aa49">ArraySize</a> () const</td></tr>
<tr class="memdesc:ac16500cdb878b302e69fdc68edd8aa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if no array and &gt; 1 if it is an array.  <br /></td></tr>
<tr class="separator:ac16500cdb878b302e69fdc68edd8aa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9d5f8b336e6fa4933a456a28c0f2ac" id="r_a3a9d5f8b336e6fa4933a456a28c0f2ac"><td class="memItemLeft" align="right" valign="top"><a id="a3a9d5f8b336e6fa4933a456a28c0f2ac" name="a3a9d5f8b336e6fa4933a456a28c0f2ac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3a9d5f8b336e6fa4933a456a28c0f2ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetChannelValue</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, std::vector&lt; uint8_t &gt; &amp;dest, uint64_t array_index) const</td></tr>
<tr class="memdesc:a3a9d5f8b336e6fa4933a456a28c0f2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that gets an array value from a record buffer. <br /></td></tr>
<tr class="separator:a3a9d5f8b336e6fa4933a456a28c0f2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01475f1def078bbcd842d983764b99f" id="r_ac01475f1def078bbcd842d983764b99f"><td class="memItemLeft" align="right" valign="top"><a id="ac01475f1def078bbcd842d983764b99f" name="ac01475f1def078bbcd842d983764b99f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac01475f1def078bbcd842d983764b99f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetChannelValue</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, std::string &amp;dest, uint64_t array_index) const</td></tr>
<tr class="memdesc:ac01475f1def078bbcd842d983764b99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that gets a string value from a record buffer. <br /></td></tr>
<tr class="separator:ac01475f1def078bbcd842d983764b99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba4be9b302561d57203d2dd6d1d9ba5" id="r_a3ba4be9b302561d57203d2dd6d1d9ba5"><td class="memItemLeft" align="right" valign="top"><a id="a3ba4be9b302561d57203d2dd6d1d9ba5" name="a3ba4be9b302561d57203d2dd6d1d9ba5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3ba4be9b302561d57203d2dd6d1d9ba5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetChannelValue</b> (const std::string &amp;value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a3ba4be9b302561d57203d2dd6d1d9ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets a string value to a record buffer. <br /></td></tr>
<tr class="separator:a3ba4be9b302561d57203d2dd6d1d9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdaabb69166cc382b1d8ff29c6f28ac" id="r_a9fdaabb69166cc382b1d8ff29c6f28ac"><td class="memItemLeft" align="right" valign="top"><a id="a9fdaabb69166cc382b1d8ff29c6f28ac" name="a9fdaabb69166cc382b1d8ff29c6f28ac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9fdaabb69166cc382b1d8ff29c6f28ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetChannelValue</b> (const std::vector&lt; uint8_t &gt; &amp;values, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a9fdaabb69166cc382b1d8ff29c6f28ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets a string value to a record buffer. <br /></td></tr>
<tr class="separator:a9fdaabb69166cc382b1d8ff29c6f28ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmdf_1_1_i_block"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classmdf_1_1_i_block')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmdf_1_1_i_block.html">mdf::IBlock</a></td></tr>
<tr class="memitem:ae457ca0b12e381f3a8239a6b34750a71 inherit pub_methods_classmdf_1_1_i_block" id="r_ae457ca0b12e381f3a8239a6b34750a71"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~IBlock</b> ()=default</td></tr>
<tr class="memdesc:ae457ca0b12e381f3a8239a6b34750a71 inherit pub_methods_classmdf_1_1_i_block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ae457ca0b12e381f3a8239a6b34750a71 inherit pub_methods_classmdf_1_1_i_block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4238fc723d16ccd8e010d098d4f45f inherit pub_methods_classmdf_1_1_i_block" id="r_a1d4238fc723d16ccd8e010d098d4f45f"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_block.html#a1d4238fc723d16ccd8e010d098d4f45f">Index</a> () const =0</td></tr>
<tr class="memdesc:a1d4238fc723d16ccd8e010d098d4f45f inherit pub_methods_classmdf_1_1_i_block"><td class="mdescLeft">&#160;</td><td class="mdescRight">File position within the file.  <br /></td></tr>
<tr class="separator:a1d4238fc723d16ccd8e010d098d4f45f inherit pub_methods_classmdf_1_1_i_block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbad6ffc878074aecd665cfcadd795e inherit pub_methods_classmdf_1_1_i_block" id="r_afdbad6ffc878074aecd665cfcadd795e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdf_1_1_i_block.html#afdbad6ffc878074aecd665cfcadd795e">BlockType</a> () const =0</td></tr>
<tr class="memdesc:afdbad6ffc878074aecd665cfcadd795e inherit pub_methods_classmdf_1_1_i_block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block type.  <br /></td></tr>
<tr class="separator:afdbad6ffc878074aecd665cfcadd795e inherit pub_methods_classmdf_1_1_i_block"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae1da89191e31edf36c8fe4d5ed894b13" id="r_ae1da89191e31edf36c8fe4d5ed894b13"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae1da89191e31edf36c8fe4d5ed894b13"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1da89191e31edf36c8fe4d5ed894b13">GetVirtualSample</a> (uint64_t sample, V &amp;value)</td></tr>
<tr class="memdesc:ae1da89191e31edf36c8fe4d5ed894b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value for a virtual sample.  <br /></td></tr>
<tr class="separator:ae1da89191e31edf36c8fe4d5ed894b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ef5bda4243fde3d9d7b71555f58ed4" id="r_a41ef5bda4243fde3d9d7b71555f58ed4"><td class="memTemplParams" colspan="2">template&lt;typename V  = std::string&gt; </td></tr>
<tr class="memitem:a41ef5bda4243fde3d9d7b71555f58ed4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41ef5bda4243fde3d9d7b71555f58ed4">GetVirtualSample</a> (uint64_t sample, std::string &amp;value)</td></tr>
<tr class="memdesc:a41ef5bda4243fde3d9d7b71555f58ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization that returns virtual sample values.  <br /></td></tr>
<tr class="separator:a41ef5bda4243fde3d9d7b71555f58ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa1e1142f67b241c5400f00f08d97dce5" id="r_aa1e1142f67b241c5400f00f08d97dce5"><td class="memItemLeft" align="right" valign="top"><a id="aa1e1142f67b241c5400f00f08d97dce5" name="aa1e1142f67b241c5400f00f08d97dce5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetSignedValue</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, int64_t &amp;dest, uint64_t array_index) const</td></tr>
<tr class="memdesc:aa1e1142f67b241c5400f00f08d97dce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that get signed integer from a record. <br /></td></tr>
<tr class="separator:aa1e1142f67b241c5400f00f08d97dce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969c683a1064ebd9b523f60534ec75b9" id="r_a969c683a1064ebd9b523f60534ec75b9"><td class="memItemLeft" align="right" valign="top"><a id="a969c683a1064ebd9b523f60534ec75b9" name="a969c683a1064ebd9b523f60534ec75b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetFloatValue</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, double &amp;dest, uint64_t array_index) const</td></tr>
<tr class="memdesc:a969c683a1064ebd9b523f60534ec75b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that get float values from a record. <br /></td></tr>
<tr class="separator:a969c683a1064ebd9b523f60534ec75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fdc32000d9154800e7b76b7f54f6b6" id="r_ac5fdc32000d9154800e7b76b7f54f6b6"><td class="memItemLeft" align="right" valign="top"><a id="ac5fdc32000d9154800e7b76b7f54f6b6" name="ac5fdc32000d9154800e7b76b7f54f6b6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetByteArrayValue</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, std::vector&lt; uint8_t &gt; &amp;dest) const</td></tr>
<tr class="memdesc:ac5fdc32000d9154800e7b76b7f54f6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that get array values from a record. <br /></td></tr>
<tr class="separator:ac5fdc32000d9154800e7b76b7f54f6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f58411ed496fec1f4b7dd4f63be873" id="r_a77f58411ed496fec1f4b7dd4f63be873"><td class="memItemLeft" align="right" valign="top"><a id="a77f58411ed496fec1f4b7dd4f63be873" name="a77f58411ed496fec1f4b7dd4f63be873"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCanOpenDate</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, uint64_t &amp;dest) const</td></tr>
<tr class="memdesc:a77f58411ed496fec1f4b7dd4f63be873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that get CANOpen date values from a record. <br /></td></tr>
<tr class="separator:a77f58411ed496fec1f4b7dd4f63be873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6258ce9e62afd72f4f4e8e9137dc7" id="r_a9bb6258ce9e62afd72f4f4e8e9137dc7"><td class="memItemLeft" align="right" valign="top"><a id="a9bb6258ce9e62afd72f4f4e8e9137dc7" name="a9bb6258ce9e62afd72f4f4e8e9137dc7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCanOpenTime</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, uint64_t &amp;dest) const</td></tr>
<tr class="memdesc:a9bb6258ce9e62afd72f4f4e8e9137dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that get CANOpen time values from a record. <br /></td></tr>
<tr class="separator:a9bb6258ce9e62afd72f4f4e8e9137dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7298472cadb74a0144da13cc7258d8" id="r_a6c7298472cadb74a0144da13cc7258d8"><td class="memItemLeft" align="right" valign="top"><a id="a6c7298472cadb74a0144da13cc7258d8" name="a6c7298472cadb74a0144da13cc7258d8"></a>
virtual std::vector&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SampleBuffer</b> () const =0</td></tr>
<tr class="memdesc:a6c7298472cadb74a0144da13cc7258d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that gets the channel group sample buffer. <br /></td></tr>
<tr class="separator:a6c7298472cadb74a0144da13cc7258d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95232e6e4f4c88721d794818e1bcbe29" id="r_a95232e6e4f4c88721d794818e1bcbe29"><td class="memItemLeft" align="right" valign="top"><a id="a95232e6e4f4c88721d794818e1bcbe29" name="a95232e6e4f4c88721d794818e1bcbe29"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetValid</b> (bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a95232e6e4f4c88721d794818e1bcbe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets the valid flag. <br /></td></tr>
<tr class="separator:a95232e6e4f4c88721d794818e1bcbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf35f4d5afeae5700d82d669c75e274" id="r_aadf35f4d5afeae5700d82d669c75e274"><td class="memItemLeft" align="right" valign="top"><a id="aadf35f4d5afeae5700d82d669c75e274" name="aadf35f4d5afeae5700d82d669c75e274"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetValid</b> (const std::vector&lt; uint8_t &gt; &amp;record_buffer, uint64_t array_index) const</td></tr>
<tr class="memdesc:aadf35f4d5afeae5700d82d669c75e274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that return true if the valid bit is set. <br /></td></tr>
<tr class="separator:aadf35f4d5afeae5700d82d669c75e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3309b74327da32fe5c831de7d6ee1336" id="r_a3309b74327da32fe5c831de7d6ee1336"><td class="memItemLeft" align="right" valign="top"><a id="a3309b74327da32fe5c831de7d6ee1336" name="a3309b74327da32fe5c831de7d6ee1336"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUnsignedValueLe</b> (uint64_t value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a3309b74327da32fe5c831de7d6ee1336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets unsigned little endian values. <br /></td></tr>
<tr class="separator:a3309b74327da32fe5c831de7d6ee1336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965b747a9c066c06fe2cd4cd396575e9" id="r_a965b747a9c066c06fe2cd4cd396575e9"><td class="memItemLeft" align="right" valign="top"><a id="a965b747a9c066c06fe2cd4cd396575e9" name="a965b747a9c066c06fe2cd4cd396575e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUnsignedValueBe</b> (uint64_t value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a965b747a9c066c06fe2cd4cd396575e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets unsigned big endian values. <br /></td></tr>
<tr class="separator:a965b747a9c066c06fe2cd4cd396575e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f68f430feeb6c20182c145738c520d" id="r_ac6f68f430feeb6c20182c145738c520d"><td class="memItemLeft" align="right" valign="top"><a id="ac6f68f430feeb6c20182c145738c520d" name="ac6f68f430feeb6c20182c145738c520d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetSignedValueLe</b> (int64_t value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:ac6f68f430feeb6c20182c145738c520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets signed little endian values. <br /></td></tr>
<tr class="separator:ac6f68f430feeb6c20182c145738c520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9b5ba030b2bc5aa68368129481c972" id="r_a7f9b5ba030b2bc5aa68368129481c972"><td class="memItemLeft" align="right" valign="top"><a id="a7f9b5ba030b2bc5aa68368129481c972" name="a7f9b5ba030b2bc5aa68368129481c972"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetSignedValueBe</b> (int64_t value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a7f9b5ba030b2bc5aa68368129481c972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets signed big endian values. <br /></td></tr>
<tr class="separator:a7f9b5ba030b2bc5aa68368129481c972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952a3b22453bc49fc2df99ee41680d90" id="r_a952a3b22453bc49fc2df99ee41680d90"><td class="memItemLeft" align="right" valign="top"><a id="a952a3b22453bc49fc2df99ee41680d90" name="a952a3b22453bc49fc2df99ee41680d90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFloatValueLe</b> (double value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a952a3b22453bc49fc2df99ee41680d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets float little endian values. <br /></td></tr>
<tr class="separator:a952a3b22453bc49fc2df99ee41680d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbbebac2e3c31a82101d727938636fe" id="r_a7cbbebac2e3c31a82101d727938636fe"><td class="memItemLeft" align="right" valign="top"><a id="a7cbbebac2e3c31a82101d727938636fe" name="a7cbbebac2e3c31a82101d727938636fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFloatValueBe</b> (double value, bool valid, uint64_t array_index)</td></tr>
<tr class="memdesc:a7cbbebac2e3c31a82101d727938636fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets float big endian values. <br /></td></tr>
<tr class="separator:a7cbbebac2e3c31a82101d727938636fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840a972e3dd3989962a001bd28c4e462" id="r_a840a972e3dd3989962a001bd28c4e462"><td class="memItemLeft" align="right" valign="top"><a id="a840a972e3dd3989962a001bd28c4e462" name="a840a972e3dd3989962a001bd28c4e462"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetTextValue</b> (const std::string &amp;value, bool valid)</td></tr>
<tr class="memdesc:a840a972e3dd3989962a001bd28c4e462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets text values. <br /></td></tr>
<tr class="separator:a840a972e3dd3989962a001bd28c4e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23116424bfaa7e5d87f2f2d8b6e232d9" id="r_a23116424bfaa7e5d87f2f2d8b6e232d9"><td class="memItemLeft" align="right" valign="top"><a id="a23116424bfaa7e5d87f2f2d8b6e232d9" name="a23116424bfaa7e5d87f2f2d8b6e232d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetByteArray</b> (const std::vector&lt; uint8_t &gt; &amp;value, bool valid)</td></tr>
<tr class="memdesc:a23116424bfaa7e5d87f2f2d8b6e232d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function that sets array values. <br /></td></tr>
<tr class="separator:a23116424bfaa7e5d87f2f2d8b6e232d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab65be17a489e6188f0974084ba306326" name="ab65be17a489e6188f0974084ba306326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65be17a489e6188f0974084ba306326">&#9670;&#160;</a></span>AddAttachmentReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mdf::IChannel::AddAttachmentReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmdf_1_1_i_attachment.html">IAttachment</a> *</td>          <td class="paramname"><span class="paramname"><em>attachment</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds an attachment reference to the channel. This function is used when writing MDF 4 files.</p>
<p>Note that this function must be called before the any measurement is started and the attachment must also be added before measurement is started. This is a design flaw in the MDF standard why for example video attachments cannot be embedded as they are created after the CN block is written. DBC files will work as they already exist when the measurement is started. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Pointer to the attachment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16500cdb878b302e69fdc68edd8aa49" name="ac16500cdb878b302e69fdc68edd8aa49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16500cdb878b302e69fdc68edd8aa49">&#9670;&#160;</a></span>ArraySize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mdf::IChannel::ArraySize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns 1 for normal channel and array size for array channels </dd></dl>

</div>
</div>
<a id="a128de0bc7aa39d1b877481bb4216d410" name="a128de0bc7aa39d1b877481bb4216d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128de0bc7aa39d1b877481bb4216d410">&#9670;&#160;</a></span>ArraySize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::ArraySize </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an internal function that speed up the reads of values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_size</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b39d985b2153dd0bd1773489f7837c" name="a92b39d985b2153dd0bd1773489f7837c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b39d985b2153dd0bd1773489f7837c">&#9670;&#160;</a></span>BitCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mdf::IChannel::BitCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>bits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function shall only be used for MDF4 files and for composition channels. Composition channels reference their parent byte array channel. For ordinary channels, the bit size and offset is calculated when the measurement is initialized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>Number of bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38e43155f97b7e9faab958be1b52832" name="aa38e43155f97b7e9faab958be1b52832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38e43155f97b7e9faab958be1b52832">&#9670;&#160;</a></span>BitOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mdf::IChannel::BitOffset </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function shall only be used for MDF4 files and for composition channels. Composition channels reference their parent byte array channel. For ordinary channels, the bit size and offset is calculated when the measurement is initialized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>Offset to data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f25048931c7687984347867a06129f6" name="a5f25048931c7687984347867a06129f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f25048931c7687984347867a06129f6">&#9670;&#160;</a></span>ByteOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mdf::IChannel::ByteOffset </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function shall only be used for MDF4 files and for composition channels. Composition channels reference their parent byte array channel. For ordinary channels, the bit size and offset is calculated when the measurement is initialized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Offset to data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa216dc859b5cf5c3f602d21e83c4f6d" name="afa216dc859b5cf5c3f602d21e83c4f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa216dc859b5cf5c3f602d21e83c4f6d">&#9670;&#160;</a></span>CalculateMasterTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mdf::IChannel::CalculateMasterTime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True means that the master channel is calculated. </dd></dl>

</div>
</div>
<a id="a1f5a405f19fb593d8ec38007ec401870" name="a1f5a405f19fb593d8ec38007ec401870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5a405f19fb593d8ec38007ec401870">&#9670;&#160;</a></span>CalculateMasterTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::CalculateMasterTime </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>calculate_master</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the channel is a master channel and the channel sync type is time, this option defines if its channel value should be calculated from the <a class="el" href="classmdf_1_1_mdf_writer.html" title="Interface against an MDF writer object.">MdfWriter</a> sample queue absolute time. Not used for reader applications.</p>
<p>Default is the option set to true i.e. the channel value will be calculated from the absolute time in the writers sample queue. If it set to false, the user is responsible to set the channels value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calculate_master</td><td>If set tp false, the user must set the channel value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a115a9a7199ae62203607ee304435b905" name="a115a9a7199ae62203607ee304435b905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a9a7199ae62203607ee304435b905">&#9670;&#160;</a></span>ChannelArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmdf_1_1_i_channel_array.html">IChannelArray</a> * mdf::IChannel::ChannelArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to get the channel array if any exist on this channel. Channel arrays require quite different handling and treatment of the channel. Normally the channel only handle one value but if the channel have a composite channel array (CA), the channel is now storing an array of values. The array may be multidimensional.</p>
<p>The function is alo used to indicate if the channel is of array type. Channel arrays only exist in MDF 4 files. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the CA block or nullptr. </dd></dl>

</div>
</div>
<a id="a76dd687896052c0425910967f077286b" name="a76dd687896052c0425910967f077286b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dd687896052c0425910967f077286b">&#9670;&#160;</a></span>ChannelCompositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> * &gt; mdf::IChannel::ChannelCompositions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a composition channel block. Composition channels reference their bit length and bit offset to its parent channel. In reality, the parent channel must be a byte array. </p>

</div>
</div>
<a id="a0f3c1efa16f7e760c3079ad6f2f1c3cf" name="a0f3c1efa16f7e760c3079ad6f2f1c3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3c1efa16f7e760c3079ad6f2f1c3cf">&#9670;&#160;</a></span>ChannelGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmdf_1_1_i_channel_group.html">IChannelGroup</a> * mdf::IChannel::ChannelGroup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Support function that returns the channel group that this channel belongs to. Note that the function may return nullptr if the channel have not been assigned a group. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the channel group. </dd></dl>

</div>
</div>
<a id="a8b86497bd0b22bfc1e892e98fbd8a3b2" name="a8b86497bd0b22bfc1e892e98fbd8a3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b86497bd0b22bfc1e892e98fbd8a3b2">&#9670;&#160;</a></span>CreateChannelArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmdf_1_1_i_channel_array.html">IChannelArray</a> * mdf::IChannel::CreateChannelArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates or returns the existing channel array (CA) block. The CA blocks are mixed with the composition (CN) blocks, see CreateChannelComposition</p>
<dl class="section return"><dt>Returns</dt><dd>A new or existing channel array (CA) block. </dd></dl>

</div>
</div>
<a id="ad29f9258dbf58727f6e556ecfde2bbce" name="ad29f9258dbf58727f6e556ecfde2bbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29f9258dbf58727f6e556ecfde2bbce">&#9670;&#160;</a></span>CreateChannelComposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> * mdf::IChannel::CreateChannelComposition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a composition channel block. Composition channels reference their bit length and bit offset to its parent channel. In reality, the parent channel must be a byte array. </p>

</div>
</div>
<a id="a864a22be7a831f2d9473292fb16827f7" name="a864a22be7a831f2d9473292fb16827f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864a22be7a831f2d9473292fb16827f7">&#9670;&#160;</a></span>CreateChannelComposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmdf_1_1_i_channel.html">IChannel</a> * mdf::IChannel::CreateChannelComposition </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a composition channel block. Composition channels reference their bit length and bit offset to its parent channel. In reality, the parent channel must be a byte array. </p>

</div>
</div>
<a id="af516e447a9e2bb6a7b1e7b46e7257525" name="af516e447a9e2bb6a7b1e7b46e7257525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af516e447a9e2bb6a7b1e7b46e7257525">&#9670;&#160;</a></span>GetChannelValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mdf::IChannel::GetChannelValue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>record_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internally used function that parse out the channel value from a sample record.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record_buffer</td><td>Data record from a data block. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination value. </td></tr>
    <tr><td class="paramname">array_index</td><td>Array offset used by channel arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="a3136a15e15cd5023c26d6b6fa2b79790" name="a3136a15e15cd5023c26d6b6fa2b79790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3136a15e15cd5023c26d6b6fa2b79790">&#9670;&#160;</a></span>GetTextValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mdf::IChannel::GetTextValue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>record_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record_buffer</td><td>The sample record buffer. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="a3e7a28ee965b4121891d76ebbeecee14" name="a3e7a28ee965b4121891d76ebbeecee14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7a28ee965b4121891d76ebbeecee14">&#9670;&#160;</a></span>GetUnsignedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdf::IChannel::GetUnsignedValue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>record_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record_buffer</td><td>The sample record buffer. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination value. </td></tr>
    <tr><td class="paramname">array_index</td><td>Array offset used by channel arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="a41ef5bda4243fde3d9d7b71555f58ed4" name="a41ef5bda4243fde3d9d7b71555f58ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ef5bda4243fde3d9d7b71555f58ed4">&#9670;&#160;</a></span>GetVirtualSample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mdf::IChannel::GetVirtualSample </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of value to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample index. </td></tr>
    <tr><td class="paramname">value</td><td>Reference to return string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="ae1da89191e31edf36c8fe4d5ed894b13" name="ae1da89191e31edf36c8fe4d5ed894b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1da89191e31edf36c8fe4d5ed894b13">&#9670;&#160;</a></span>GetVirtualSample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mdf::IChannel::GetVirtualSample </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual samples are calculated from the sample index instead of the channel value as normally.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of value to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>Sample index. </td></tr>
    <tr><td class="paramname">value</td><td>Reference to return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is valid. </dd></dl>

</div>
</div>
<a id="a258517eee06f2275d4edc29f6e92268f" name="a258517eee06f2275d4edc29f6e92268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258517eee06f2275d4edc29f6e92268f">&#9670;&#160;</a></span>RecordId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mdf::IChannel::RecordId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient function that returns the record ID for the channel group which the channel belongs to. </p><dl class="section return"><dt>Returns</dt><dd>Returns the record ID. </dd></dl>

</div>
</div>
<a id="a0f02ecc9cf3760267c95b7eb4e1868d8" name="a0f02ecc9cf3760267c95b7eb4e1868d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f02ecc9cf3760267c95b7eb4e1868d8">&#9670;&#160;</a></span>SetChannelValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::SetChannelValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>valid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is used when writing MDF files. The function take an unscaled channel value and insert it into the channel groups record buffer. This record buffer is later saved to the MDF file by calling the IChannelGroup::SaveSample() function.</p>
<p>If the channel is a channel array, the array index argument needs to be set. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to transfer. </td></tr>
    <tr><td class="paramname">valid</td><td>True if the value is valid. </td></tr>
    <tr><td class="paramname">array_index</td><td>Channel array index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad694470ca2821905f1b957a72a90f0f9" name="ad694470ca2821905f1b957a72a90f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad694470ca2821905f1b957a72a90f0f9">&#9670;&#160;</a></span>SetChannelValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::SetChannelValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function shall be used to simplify setting channel array values. The function assumes that all values are valid. If values may be invalid, the <a class="el" href="#a0f02ecc9cf3760267c95b7eb4e1868d8" title="Sets a channel value.">SetChannelValue()</a> function should be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>1-Dimensional list of array values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33a5529d183edeb6b881c791f3a3c451" name="a33a5529d183edeb6b881c791f3a3c451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a5529d183edeb6b881c791f3a3c451">&#9670;&#160;</a></span>SetTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::SetTimestamp </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>record_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function update the record buffer with a new time. This function is for internal use and its purpose is to change the timestamps in the sample cache queue, from absolute time to relative time. This happens when the <a class="el" href="classmdf_1_1_mdf_writer.html#a3d8644bac04ec6f8189a216967fd3705" title="Starts the measurement.">MdfWriter::StartMeasurement()</a> function is called </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>Relative time in seconds. </td></tr>
    <tr><td class="paramname">record_buffer</td><td>The record buffer to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0d4d05b309f1fdf0428eb1d381887df" name="ac0d4d05b309f1fdf0428eb1d381887df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d4d05b309f1fdf0428eb1d381887df">&#9670;&#160;</a></span>Unit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string mdf::IChannel::Unit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The unit describes the engineering/scaled value not the channel value itself. This might be considered as a design flaw as the CC block also have a unit.</p>
<p>This function returns the channels unit first and if it doesn't exist, returns the CC blocks unit.</p>
<p>For MIME streams this unit is actually the type of stream content. </p><dl class="section return"><dt>Returns</dt><dd>Unit or MIME content string. Returns the unit </dd></dl>

</div>
</div>
<a id="a36a3b88bc8d1a5844d04289e89e826c4" name="a36a3b88bc8d1a5844d04289e89e826c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a3b88bc8d1a5844d04289e89e826c4">&#9670;&#160;</a></span>Unit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mdf::IChannel::Unit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>unit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the unit string for the channel. If the channel data type is a MIME sample or a stream, the unit is a mime content type string.</p>
<p>Note that this unit belongs to the value after scaling (CC) i.e. engineering value. </p>

</div>
</div>
<a id="a34f93d53a8257129fbf322861c4b002c" name="a34f93d53a8257129fbf322861c4b002c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f93d53a8257129fbf322861c4b002c">&#9670;&#160;</a></span>VlsdRecordId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mdf::IChannel::VlsdRecordId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is mainly used internally and solves the problem if the channel is a variable length and its value is stored in another (VLSD) channel group (CG). This property is set to the record ID of the VLSD block. </p><dl class="section return"><dt>Returns</dt><dd>Record id of the block storing the data bytes. </dd></dl>

</div>
</div>
<a id="af0097710fe52be6fa446944cd9f126bf" name="af0097710fe52be6fa446944cd9f126bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0097710fe52be6fa446944cd9f126bf">&#9670;&#160;</a></span>VlsdRecordId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdf::IChannel::VlsdRecordId </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>record_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is mainly used internally and solves the problem if the channel is a variable length and its value is stored in another (VLSD) channel group (CG). This property is set to the record ID of the VLSD block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record_id</td><td>Record id of the block storing the data bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mdf/<a class="el" href="ichannel_8h_source.html">ichannel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
